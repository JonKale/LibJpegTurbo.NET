namespace LibJpegTurbo.Net
{
    #region Using Directives

    using System;

    #endregion

    /// <summary>TurboJPEG lossless transformer.</summary>
    public sealed class TurboJpegTransformer : TurboJpegDecompressor
    {
        #region Constants and Fields

        /// <summary>
        /// The sizes of the transformed output. </summary>
        private int[] transformedSizes;

        #endregion

        #region Constructors and Destructors

        /// <summary>Create a TurboJPEG lossless transformer instance.</summary>
        public TurboJpegTransformer()
            : base(TurboJpegInterop.initTransformer())
        {
        }

        /// <summary>
        /// Create a TurboJPEG lossless transformer instance and associate the JPEG image stored in 
        /// <paramref name="jpegImage"/> with the newly created instance.
        /// </summary>
        /// <param name="jpegImage">JPEG image buffer (size of the JPEG image is implicitly the length of the array).</param>
        public TurboJpegTransformer(sbyte[] jpegImage)
            : base(TurboJpegInterop.initTransformer())
        {
            this.SetJpegImage(jpegImage, jpegImage.Length);
        }

        /// <summary>
        /// Create a TurboJPEG lossless transformer instance and associate the JPEG image of length 
        /// <paramref name="imageSize"/> bytes stored in <paramref name="jpegImage"/> with the newly created instance.
        /// </summary>
        /// <param name="jpegImage">JPEG image buffer.</param>
        /// <param name="imageSize">Size of the JPEG image (in bytes).</param>
        public TurboJpegTransformer(sbyte[] jpegImage, int imageSize)
            : base(TurboJpegInterop.initTransformer())
        {
            this.SetJpegImage(jpegImage, imageSize);
        }

        #endregion

        #region Public Properties

        /// <summary>
        /// Returns an array containing the sizes of the transformed JPEG images generated by the most recent 
        /// transform operation.
        /// </summary>
        /// <returns>An array containing the sizes of the transformed JPEG images generated by the most recent 
        /// transform operation </returns>
        public int[] TransformedSizes
        {
            get
            {
                if (this.transformedSizes == null)
                {
                    throw new InvalidOperationException("No image has been transformed yet");
                }

                return this.transformedSizes;
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Losslessly transform the JPEG image associated with this transformer instance into one or more JPEG images
        /// stored in the given destination buffers. Lossless transforms work by moving the raw coefficients from one 
        /// JPEG image structure to another without altering the values of the coefficients. While this is typically 
        /// faster than decompressing the image, transforming it, and re-compressing it, lossless transforms are not 
        /// free. Each lossless transform requires reading and performing Huffman decoding on all of the coefficients 
        /// in the source image, regardless of the size of the destination image, thus this method provides a means of 
        /// generating multiple transformed images from the same source or of applying multiple transformations 
        /// simultaneously, in order to eliminate the need to read the source coefficients multiple times.
        /// </summary>
        /// <param name="dstBufs">
        /// An array of image buffers. <paramref name="dstBufs"/>[i] will receive a JPEG image that has been
        ///  transformed using the parameters in <paramref name="transforms"/>[i].  Use 
        /// <see cref="TurboJpegInterop.bufSize" /> to determine the maximum size for each buffer based on the 
        /// transformed or cropped width and height and the chroma subsampling used in the source image.
        /// </param>
        /// <param name="transforms">An array of <seealso cref="TurboJpegTransform" /> instances, each of which 
        /// specifies the transform parameters and/or cropping region for the corresponding transformed output image.
        /// </param>
        /// <param name="flags">The options to use for the transforms.</param>
        public void Transform(byte[][] dstBufs, TurboJpegTransform[] transforms, TransformOptions flags)
        {
            if (this.JpegBuffer == null)
            {
                throw new InvalidOperationException("JPEG buffer not initialized");
            }

            this.transformedSizes = TurboJpegInterop.transform(this.Handle,
                                                               this.JpegBuffer,
                                                               this.JpegSize,
                                                               transforms.Length,
                                                               dstBufs,
                                                               ref this.transformedSizes,
                                                               transforms,
                                                               (int)flags);
        }

        /// <summary>
        /// Losslessly transform the JPEG image associated with this transformer instance and return an array of
        /// <seealso cref="TurboJpegDecompressor" /> instances, each of which has a transformed JPEG image associated 
        /// with it.
        /// </summary>
        /// <param name="transforms">An array of <see cref="TurboJpegTransform" /> instances, each of which specifies 
        /// the transform parameters and/or cropping region for the corresponding transformed output image.</param>
        /// <param name="options">The options to use when transforming.</param>
        /// <returns>An array of <seealso cref="TurboJpegDecompressor" /> instances, each of which has a transformed 
        /// JPEG image associated with it.</returns>
        public TurboJpegDecompressor[] Transform(TurboJpegTransform[] transforms, TransformOptions options)
        {
            var destinationBuffers = new sbyte[transforms.Length][];
            if (this.JpegWidth < 1 || this.JpegHeight < 1)
            {
                throw new InvalidOperationException("JPEG buffer not initialized");
            }

            for (var i = 0; i < transforms.Length; i++)
            {
                var width = this.JpegWidth;
                var height = this.JpegHeight;
                if ((transforms[i].Options & TransformOptions.Crop) != 0)
                {
                    if (transforms[i].Width != 0)
                    {
                        width = transforms[i].Width;
                    }

                    if (transforms[i].Height != 0)
                    {
                        height = transforms[i].Height;
                    }
                }

                destinationBuffers[i] = new sbyte[TurboJpegInterop.bufSize(width, height, (int)this.JpegSubsampling)];
            }
            var decompressors = new TurboJpegDecompressor[transforms.Length];
            this.Transform(destinationBuffers, transforms, options);
            for (var i = 0; i < transforms.Length; i++)
            {
                decompressors[i] = new TurboJpegDecompressor(destinationBuffers[i], this.transformedSizes[i]);
            }

            return decompressors;
        }

        #endregion
    }
}