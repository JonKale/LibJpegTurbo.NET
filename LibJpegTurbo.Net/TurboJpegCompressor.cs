namespace LibJpegTurbo.Net
{
    #region Using Directives

    using System;
    using System.Diagnostics.Contracts;
    using System.Runtime.InteropServices;

    #endregion

    /// <summary>
    /// TurboJPEG compressor
    /// </summary>
    internal sealed class TurboJpegCompressor : TurboJpegBase
    {
        #region Constants and Fields

        /// <summary>
        /// The JPEG quality level used for compress operations.
        /// </summary>
        private int jpegQuality = -1;

        /// <summary>
        /// The buffer containing the source image.
        /// </summary>
        private byte[] sourceBuffer;

        /// <summary>
        /// The height of the region of the source image to compress.
        /// </summary>
        private int sourceHeight;

        /// <summary>
        /// The pitch of the source image.
        /// </summary>
        private int sourcePitch;

        /// <summary>
        /// The pixel format of the source image.
        /// </summary>
        private PixelFormat sourcePixelFormat;

        /// <summary>
        /// The width of the region of the source image to compress.
        /// </summary>
        private int sourceWidth;

        /// <summary>
        /// The X offset of the region of the source image to compress.
        /// </summary>
        private int sourceX = -1;

        /// <summary>
        /// The Y offset of the region of the source image to compress.
        /// </summary>
        private int sourceY = -1;

        #endregion

        #region Constructors and Destructors

        /// <summary>Create a TurboJPEG compressor instance.</summary>
        public TurboJpegCompressor()
            : base(NativeMethods.initCompressor())
        {
        }

        /// <summary>
        /// Create a TurboJPEG compressor instance and associate the uncompressed source image stored in
        /// <code>sourceImage</code> with the newly created instance.
        /// </summary>
        /// <param name="sourceImage">Image buffer containing RGB or grayscale pixels to be compressed or encoded.</param>
        /// <param name="x">X offset (in pixels) of the region in the source image from which the JPEG or YUV image 
        /// should be compressed/encoded.</param>
        /// <param name="y">Y offset (in pixels) of the region in the source image from which the JPEG or YUV image 
        /// should be compressed/encoded.</param>
        /// <param name="width">Width (in pixels) of the region in the source image from which the JPEG or YUV image 
        /// should be compressed/encoded.</param>
        /// <param name="pitch">Bytes per line of the source image. Normally, this should be 
        /// <code>width * <see cref="TurboJpegUtilities.GetPixelSize"/>(<paramref name="pixelFormat"/>)</code> if the 
        /// source image is unpadded, but you can use this parameter to, for instance, specify that the scanlines in 
        /// the source image are padded to a 4-byte boundary or to compress/encode a JPEG or YUV image from a region 
        /// of a larger source image. You can also be clever and use this parameter to skip lines, etc. Setting this 
        /// parameter to 0 is the equivalent of setting it to 
        /// <code>width * <see cref="TurboJpegUtilities.GetPixelSize"/>(<paramref name="pixelFormat"/>)</code>.
        /// </param>
        /// <param name="height">Height (in pixels) of the region in the source image from which the JPEG or YUV image 
        /// should be compressed/encoded.</param>
        /// <param name="pixelFormat">Pixel format of the source image. </param>
        public TurboJpegCompressor(byte[] sourceImage,
                                   int x,
                                   int y,
                                   int width,
                                   int pitch,
                                   int height,
                                   PixelFormat pixelFormat)
            : base(NativeMethods.initCompressor())
        {
            Contract.Requires(sourceImage != null, "sourceImage must not be null");
            Contract.Requires(x >= 0, "x must be non-negative");
            Contract.Requires(y >= 0, "y must be non-negative");
            Contract.Requires(width > 0, "width must be greater than zero");
            Contract.Requires(height > 0, "height must be greater than zero");
            Contract.Requires(pitch >= 0, "pitch must be non-negative");

            this.SetSourceImage(sourceImage, x, y, width, pitch, height, pixelFormat);
        }

        #endregion

        #region Public Properties

        /// <summary>Returns the size of the image (in bytes) generated by the most recent compress/encode operation.</summary>
        /// <returns> the size of the image (in bytes) generated by the most recent compress/encode operation </returns>
        public int CompressedSize { get; private set; }

        /// <summary>Set the JPEG image quality level for subsequent compress operations (1 = worst to 100 = best).</summary>
        public int JpegQuality
        {
            set
            {
                Contract.Requires(value >= 1 && value <= 100, "JpegQuality must be between 1 and 100");

                this.jpegQuality = value;
            }

            get { return this.jpegQuality; }
        }

        /// <summary>Get or set the level of chrominance subsampling for subsequent compress/encode operations.</summary>
        public Subsampling Subsampling { get; set; }

        #endregion

        #region Public Methods

        /// <summary>Free the native structures associated with this compressor instance.</summary>
        public void Close()
        {
            this.Dispose(true);
        }

        /// <summary>
        /// Compress the uncompressed source image associated with this compressor instance and output a
        /// <see cref="TurboJpegBuffer" /> pointing to a JPEG image in memory.
        /// </summary>
        /// <param name="compressionOptions">Flags controlling compression.</param>
        /// <returns>A <see cref="TurboJpegBuffer"/> pointing to a JPEG image.</returns>
        /// <exception cref="System.InvalidOperationException">The source image has not been set.</exception>
        public TurboJpegBuffer Compress(TurboJpegFlags compressionOptions)
        {
            Contract.Requires(Enum.IsDefined(typeof(TurboJpegFlags), compressionOptions));
            Contract.Assume(this.sourceBuffer != null, "No source image is associated with this instance");
            Contract.Assume(this.jpegQuality >= 0, "JPEG quality not set");

            var bufferSize =
                (ulong) NativeMethods.bufSize(this.sourceWidth, this.sourceHeight, this.Subsampling);
                
            // having allocated memory with the libjpeg-turbo allocator, we must ensure that we release it with the 
            // matching deallocator lest Bad Things happen
            var buffer = NativeMethods.alloc((int) bufferSize);
            try
            {
                if (this.sourceX >= 0 || this.sourceY >= 0)
                {
                    if (NativeMethods.compress(this.Handle,
                                                  this.sourceBuffer,
                                                  this.sourceWidth,
                                                  this.sourcePitch,
                                                  this.sourceHeight,
                                                  this.sourcePixelFormat,
                                                  ref buffer,
                                                  ref bufferSize,
                                                  this.Subsampling,
                                                  this.jpegQuality,
                                                  compressionOptions) != 0)
                    {
                        throw new Exception(Marshal.PtrToStringAnsi(NativeMethods.getErrorMessage()));
                    }
                }

                // we now have the result in a buffer on the unmanaged heap. It may have moved from the original, 
                // but libjpeg-turbo has handled the reallocation for us
                return new TurboJpegBuffer(buffer, (int)bufferSize);
            }
            catch
            {
                NativeMethods.free(buffer);
                throw;
            }
        }

        /// <summary>
        /// Encode the uncompressed source image associated with this compressor instance and output a YUV planar 
        /// image to the given destination buffer. This method uses the accelerated colour conversion routines in 
        /// TurboJPEG's underlying codec to produce a planar YUV image that is suitable for direct video display.  
        /// Specifically, if the chroma components are subsampled along the horizontal dimension, then the width of 
        /// the luma plane is padded to the nearest multiple of 2 in the output image (same goes for the height of the 
        /// luma plane, if the chroma components are subsampled along the vertical dimension.) Also, each line of each 
        /// plane in the output image is padded to 4 bytes. Although this will work with any subsampling option, it is 
        /// really only useful in combination with <see cref="P:Subsampling.Chroma420" />, which produces an image 
        /// compatible with the I420 (AKA "YUV420P") format.
        /// <para>
        /// NOTE: Technically, the JPEG format uses the YCbCr colourspace but following the convention of the digital 
        /// videocommunity (who, it's broadly admitted, didn't know anywhere near enough about video when they 
        /// invented digital video), the TurboJPEG API uses "YUV" to refer to an image format consisting of Y, Cb, 
        /// and Cr image planes.
        /// </para>
        /// </summary>
        /// <param name="destinationBuffer">A buffer that will receive the YUV planar image. Use
        /// <see cref="TurboJpegInterop.bufSizeYUV" /> to determine the appropriate size for this buffer based on the 
        /// image width, height and chroma subsampling.</param>
        /// <param name="compressionOptions">Set of flags controlling compression.</param>
        public void EncodeYuv(byte[] destinationBuffer, TurboJpegFlags compressionOptions)
        {
            Contract.Requires(destinationBuffer != null, "destinationBuffer must not be null");
            Contract.Assume(this.sourceBuffer != null, "No source image is associated with this instance");

            NativeMethods.encodeYUV(this.Handle,
                                       this.sourceBuffer,
                                       this.sourceWidth,
                                       this.sourcePitch,
                                       this.sourceHeight,
                                       this.sourcePixelFormat,
                                       destinationBuffer,
                                       this.Subsampling,
                                       compressionOptions);
            this.CompressedSize = NativeMethods.bufSizeYUV(this.sourceWidth,
                                                              this.sourcePitch,
                                                              this.sourceHeight,
                                                              this.Subsampling);
        }

        /// <summary>
        /// Encode the uncompressed source image associated with this compressor instance and return a buffer containing a
        /// YUV planar image. See <see cref="EncodeYuv(byte[], TurboJpegFlags)" /> for more detail.
        /// </summary>
        /// <param name="compressionOptions">Set of flags controlling compression.</param>
        /// <returns> a buffer containing a YUV planar image </returns>
        public byte[] EncodeYuv(TurboJpegFlags compressionOptions)
        {
            Contract.Ensures(Contract.Result<byte[]>().Length != 0, "output buffer must not be zero bytes long");
            Contract.Assume(this.sourceWidth > 0 && this.sourceHeight > 0,
                            "No source image is associated with this instance");

            var buf =
                new byte[
                    NativeMethods.bufSizeYUV(this.sourceWidth,
                                                this.sourcePitch,
                                                this.sourceHeight,
                                                this.Subsampling)];
            this.EncodeYuv(buf, compressionOptions);
            return buf;
        }

        /// <summary>
        /// Associate an uncompressed source image with this compressor instance.
        /// </summary>
        /// <param name="sourceImage">Image buffer containing RGB or grayscale pixels to be compressed or encoded.</param>
        /// <param name="x">X offset (in pixels) of the region in the source image from which the JPEG or YUV image 
        /// should be compressed/encoded.</param>
        /// <param name="y">Y offset (in pixels) of the region in the source image from which the JPEG or YUV image 
        /// should be compressed/encoded.</param>
        /// <param name="width">Width (in pixels) of the region in the source image from which the JPEG or YUV image 
        /// should be compressed/encoded.</param>
        /// <param name="pitch">Bytes per line of the source image. Normally, this should be 
        /// <code>width * <see cref="TurboJpegUtilities.GetPixelSize"/>(<paramref name="pixelFormat"/>)</code> if the 
        /// source image is unpadded, but you can use this parameter to, for instance, specify that the scanlines in 
        /// the source image are padded to a 4-byte boundary or to compress/encode a JPEG or YUV image from a region 
        /// of a larger source image. You can also be clever and use this parameter to skip lines, etc. Setting this 
        /// parameter to 0 is the equivalent of setting it to 
        /// <code>width * <see cref="TurboJpegUtilities.GetPixelSize"/>(<paramref name="pixelFormat"/>)</code>.
        /// </param>
        /// <param name="height">Height (in pixels) of the region in the source image from which the JPEG or YUV image 
        /// should be compressed/encoded.</param>
        /// <param name="pixelFormat">Pixel format of the source image.</param>
        public void SetSourceImage(byte[] sourceImage,
                                   int x,
                                   int y,
                                   int width,
                                   int pitch,
                                   int height,
                                   PixelFormat pixelFormat)
        {
            Contract.Requires(sourceImage != null, "sourceImage must not be null");
            Contract.Requires(x >= 0, "x must be non-negative");
            Contract.Requires(y >= 0, "y must be non-negative");
            Contract.Requires(width > 0, "width must be greater than zero");
            Contract.Requires(height > 0, "height must be greater than zero");
            Contract.Requires(pitch >= 0, "pitch must be non-negative");

            this.sourceBuffer = sourceImage;
            this.sourceWidth = width;
            this.sourcePitch = pitch == 0 ? width * TurboJpegUtilities.GetPixelSize(pixelFormat) : pitch;
            this.sourceHeight = height;
            this.sourcePixelFormat = pixelFormat;
            this.sourceX = x;
            this.sourceY = y;
        }

        #endregion
    }
}